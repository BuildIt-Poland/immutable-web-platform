# from: https://knative.dev/docs/serving/samples/hello-world/helloworld-nodejs/

{config, lib, project-config, pkgs, kubenix, ...}: 
let
  express-app = pkgs.callPackage ./image.nix {};
  fn-config = pkgs.callPackage ./config.nix {};
  package = pkgs.callPackage ./package.nix {};

  tests = import ./test { 
    inherit pkgs; 
    docker = express-app;
  };

  # TODO move call-function 
  scripts = import ./scripts { inherit pkgs; };

  namespaces= project-config.kubernetes.namespace;

  # FIXME ingress port for isio - instead of 31380
  call-function = 
    (pkgs.writeScriptBin "call-express-app-function" ''
      ${pkgs.curl}/bin/curl '-sS' '-H' 'Host: ${fn-config.label}.${namespaces.functions}.${fn-config.domain}' \
        http://$(${pkgs.minikube}/bin/minikube ip -p ${project-config.project.name}):31380 -v
    '');
in
{
  imports = with kubenix.modules; [ 
    k8s 
    docker-registry
    knative-serve
    k8s-extension
  ];

  module.packages = {
    express-app = package;
  };

  module.tests = tests;

  module.scripts = [
    call-function
  ];

  docker.images.express-app.image = express-app;

  kubernetes.api."knative-serve-service" = {
    "${fn-config.label}" = {
      metadata = {
        name = fn-config.label;
        namespace = namespaces.functions;
      };
      spec = {
        template = {
          metadata = {
            # app = project-config.projectName;
            # https://github.com/knative/docs/blob/master/docs/serving/samples/autoscale-go/README.md
            annotations = {
              "autoscaling.knative.dev/class" = "kpa.autoscaling.knative.dev";
              "autoscaling.knative.dev/metric" = "concurrency";
              "autoscaling.knative.dev/target" = "5";
              "autoscaling.knative.dev/maxScale" = "100";
            };
          };
          spec = {
            containers = [{
              image = config.docker.images.express-app.path;

              imagePullPolicy = project-config.kubernetes.imagePullPolicy;
              env = fn-config.env;
              livenessProbe = {
                httpGet = {
                  path = "/healthz";
                };
                initialDelaySeconds = 3;
                periodSeconds = 3;
              };
              resources = {
                requests = {
                  cpu = fn-config.cpu;
                };
              };
            }];
          };
        };
      };
    };
  };

  # https://github.com/knative/docs/blob/master/docs/serving/using-a-custom-domain.md#apply-from-a-file

  # kubectl edit gateway knative-ingress-gateway -n knative-serving
  # ingressgateway

  # kubectl -n istio-system \
  # patch gateway istio-autogenerated-k8s-ingress --type=json \
  # -p='[{"op": "replace", "path": "/spec/servers/1/tls", "value": {"credentialName": "ingress-cert", "mode": "SIMPLE", "privateKey": "sds", "serverCertificate": "sds"}}]'

  # kubectl -n knative-serving \
  # patch gateway knative-ingress-gateway --type=json \
  # -p='[{"op": "replace", "path": "/spec/servers/1/tls", "value": {"credentialName": "ingress-cert", "mode": "SIMPLE", "privateKey": "sds", "serverCertificate": "sds"}}]'
  kubernetes.api.configmaps = {
    knative-domain = {
      metadata = {
        name = "config-domain";
        namespace = "knative-serving";
        labels = {
          "networking.knative.dev/certificate-provider" = "cert-manager";
        };
      };
      data = {
        "${project-config.project.make-sub-domain ""}" = "";
      };
    };
    knative-cert = {
      metadata = {
        name = "config-certmanager";
        # namespace = "${kn-serving}";
        namespace = "knative-serving";
        labels = {
          "networking.knative.dev/certificate-provider" = "cert-manager";
        };
      };
      data = {
        secretName = "ingress-cert";
        issuerRef = ''
          name: cert-issuer
          kind: ClusterIssuer
        '';
        autoTLS = "Enabled";
        httpProtocol = "Redirected";
        solverConfig = ''
          dns01:
            provider: route53
        '';
      };
    };
  };
}